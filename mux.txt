
module mux(LEDR, SW);
    input [9:0] SW; // bus of 10 switches
    output [9:0] LEDR; // string of 10 LEDs

    mux4to1 u0(
        .u(SW[0]), // input u corresponds to switch   0
	.v(SW[1]),  // input v corresponds to switch  1
	.w(SW[2]),  // input w corresponds to switch  2
	.z(SW[3])   // input z corresponds to switch  3
	.s0(SW[8]), // s0 is outputted thru switch 8
	.s1(SW[9]), // s1 is outputted thru switch 9
	.n(LEDR[0]) // OUTPUT n corresponds to LEDR 0
        );
endmodule


module mux4to1(u, v, w, z, s0, s1, n);
  input u; // selected when s0 is 0
  input v; // selected when s0 is 1
  input w; // selected when s0 is 0
  input z; // selected when s0 is 1
  input s0; // select signal for both u0, u1
  input s1; // select signal for u2 only
  output n; // the single OUTPUT
 
  wire conn0; // the wire for u0 (to u2)
  wire conn1; // the wire for u1 (to u2)
 
  mux2to1 u0(
        .x(u), // input: 0
        .y(v), // input: 1
        .s(s0), // input: 0 for u, 1 for v
        .m(conn0) // OUTPUTs u/v
       );
 
  mux2to1 u1(
        .x(w), // input: 0
        .y(z), // input: 1
        .s(s0), // input: 0 for w, 1 for z
        .m(conn1) // OUTPUTs w/z
        ); 

  mux2to1 u2(
        .x(conn0), // input = u0 output
        .y(conn1), // input = u1 output
        .s(s1), // 0 = conn0 (u/v), 1 = conn1 (x/y)
        .m(n) // OUTPUTs to LEDR[0]
        );

endmodule
        
       
module mux2to1(x, y, s, m);
    input x; //selected when s is 0
    input y; //selected when s is 1
    input s; //select signal
    output m; //output
  
    assign m = s & y | ~s & x;
    // OR
    // assign m = s ? y : x;

endmodule

